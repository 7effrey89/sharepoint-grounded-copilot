import azure.functions as func
import logging
import re
import json

#settings for making a function in azure functions
#V2 programming model
#HTTP Trigger
#job type: append to app
#provide a function name: MyCustomSkillApp
#authorization levle: function

#To debug the skillset use the "log" function in azure functions
#The log console will not refresh unless you Delete the indexer in AI search, and then recreate it. Runs it runs you should be able to see all the logging.info() messages in the console

app = func.FunctionApp(http_auth_level=func.AuthLevel.FUNCTION)

@app.route(route="MyCustomSkillApp")
def MyCustomSkillApp(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')

    try:
        req_body = req.get_json()
        logging.info("Input:")
        logging.info(req_body)
    except ValueError:
        logging.info("Invalid Json")
        return func.HttpResponse(
            "Invalid JSON",
            status_code=400
        )

    def extract_inner_html(data):
        inner_html_list = []
        if isinstance(data, dict):
            # logging.info("----------------dict----------------") #Det er en dict
            for key, value in data.items():
                # logging.info("----------------key----------------")
                # logging.info(key)
                if key.lower() == 'innerhtml': 
                    inner_html_list.append(value)
                else:
                    inner_html_list.extend(extract_inner_html(value))
        elif isinstance(data, list):
            # logging.info("----------------list----------------")
            for item in data:
                inner_html_list.extend(extract_inner_html(item))
        
        return inner_html_list

    values = req_body.get('values', [])
    results = []

    for value in values:
        record_id = value.get('recordId') #getting the recordId from the json object generated by ai search. Mandatory to return the recordId in the response
        data = value.get('data', {}) #identifying the data property from AI search that contains the fields we want as input to our custom skillset/azure functions

        # Parse the inner JSON string

        # It seems AI Search is handling the text property (that contains our document content) as a string possibly because the content contains html tags and double quotes, so it seems we need to parse it as a JSON object (so we can have it recognized the key-value pairs)
        try:
            #Use this approach for when azure function is used as a skillset and input is derived from AI Search.
            text = data.get('text', '{}') #text property that we defined in the ai skillset to contain the content of our json document (from sharepoint). We use this to explicitly convert it to a string so we can parse it as a json object again.
            inner_data = json.loads(text) #this will trigger the Error: "the JSON object must be str, bytes or bytearray' when the azure function is used as a regular api
            inner_html_list = extract_inner_html(inner_data)
            # results.extend(inner_html_list)
        except TypeError:
            #Use this approach for when azure function is as a regular api
            # logging.info("Error decoding JSON for recordId:")
            # logging.info(record_id)
            inner_html_list = extract_inner_html(data) #funny enough when using it as a regular api, there seems to be no need to re-parse anything as json.

            
        # inner_html_list = extract_inner_html(text)

        #logging.info("__________REC__________")
        #logging.info(record_id)

        #logging.info("__________data__________")
        #logging.info(data)

        #logging.info("__________inner_html_list__________")
        #logging.info(inner_html_list)

        # Extract Arbejdssteder and Roller from all innerHTML values
        arbejdssteder_list = []
        roller_list = []
        informationstype_list = []
        overordnet_emne_list = []
        emne_list = []

        for inner_html in inner_html_list:
            arbejdssteder_match = re.search(r'<p><strong>Arbejdssteder</strong></p><p>(.*?)</p>', inner_html)
            if arbejdssteder_match:
                arbejdssteder_list.append(arbejdssteder_match.group(1))

            roller_match = re.search(r'<p><strong>Roller</strong></p><p>(.*?)</p>', inner_html)
            if roller_match:
                roller_list.append(roller_match.group(1))

            # Informationstype
            informationstype_match = re.search(r'<p><strong>Informationstype</strong></p><p>(.*?)</p>', inner_html)
            if informationstype_match:
                informationstype_list.append(informationstype_match.group(1))

            # Overordnet emne
            overordnet_emne_match = re.search(r'<p><strong>Overordnet emne</strong></p><p>(.*?)</p>', inner_html)
            if overordnet_emne_match:
                overordnet_emne_list.append(overordnet_emne_match.group(1))

            # Emne
            emne_match = re.search(r'<p><strong>Emne</strong></p><p>(.*?)</p>', inner_html)
            if emne_match:
                emne_list.append(emne_match.group(1))

        # Prepare the response for each record
        result = {
            "recordId": record_id,
            "data": {
                "Arbejdssteder": arbejdssteder_list[0] if arbejdssteder_list else "Ukendt", #can also be replaced with None
                "Roller": roller_list[0] if roller_list else "Ukendt", #can also be replaced with None
                "Informationstype": informationstype_list[0] if informationstype_list else "Ukendt",
                "Overordnet_emne": overordnet_emne_list[0] if overordnet_emne_list else "Ukendt",
                "Emne": emne_list[0] if emne_list else "Ukendt"
            },
            "errors": None,
            "warnings": None
        }

        # # Add errors if necessary
        # if not arbejdssteder_list:
        #     result["errors"] = [{"message": "'Arbejdssteder' should not be null or empty"}]
        # if not roller_list:
        #     result["errors"] = result["errors"] or []
        #     result["errors"].append({"message": "'Roller' should not be null or empty"})

        results.append(result)

    response = {
        "values": results
    }

    logging.info("Output:")
    logging.info(json.dumps(response))


    return func.HttpResponse(
        body=json.dumps(response),
        status_code=200,
        mimetype="application/json"
    )